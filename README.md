# lecture.2
# **Scope**
Область видимости или Scope
>Область видимости (scope) определяет видимость или доступность переменной (другого ресурса) в области твоего кода.
Области также могут быть разделены на слои в иерархии, чтобы дочерние области имели доступ к родительским областям, но не наоборот.

- Глобальная область видимости или Global Scope -В JavaScript есть только одна глобальная область. Область за пределами всех функций считается глобальной областью, и переменные, определенные в глобальной области, могут быть доступны и изменены в любых других областях.

- **Локальная область видимости или Local Scope** -Переменные, объявленные внутри функций, становятся локальными для функции и рассматриваются в соответствующей локальной области. Каждая функция имеет свою область видимости. Одна и та же переменная может использоваться в разных функциях, поскольку они связаны с соответствующими функциями и не являются взаимно видимыми.

> Локальная область видимости может быть разделена на область видимости функции и область видимости блока. Концепция область видимости блока или block scope была представлена в ECMAScript6 (ES6) вместе с новыми способами объявления переменных - const и let.

- **Область видимости функции Function scope** -Всякий раз, когда мы объявляем переменную в функции, переменная видна только внутри функции. Мы не можем получить к ней доступ вне функции. var - это ключевое слово, определяющее переменную для доступности области функций.

- **Область видимости блока Bloce scope** -Область видимости блока - это область в условиях **if** и **switch** или циклов **for**, и **while**. Вообще говоря, всякий раз, когда мы видим фигурные скобки **{}** - это блок. В ES6 ключевые слова **const** и **let** позволяют разработчикам объявлять переменные в области видимости блока, что означает, что эти переменные существуют только в соответствующем блоке.

- **Область модуля Modale scope** - область действия кода, работающего в модульном режиме. 

# Hoisting
> Поднятие предполагает, что объявления переменных **var** и функций **function** физически перемещаются в начало кода, но, на самом деле это не так.

> По сути, когда Javascript компилирует весь код, все объявления переменных, использующие **var**, поднимаются/hoisted в верхнюю часть их функциональной/локальной области видимости (если объявляется внутри функции) или в глобальную область видимости (если объявляется вне функции) независимо от того, где была сделана фактическая декларация.

> Объявления переменных и функций помещаются в память на этапе компиляции, но они остаются именно там, где мы ввели их в свой код.

> Итак, под капотом происходит следующее: на этапе создания, движок **JavaScript** просматривает код и, как только он видит ключевое слово var или ключевое слово function, он выделяет некоторую память для них.

### Поднятие const, let и var
**var** - это традиционный способ объявления переменных в JavaScript.

ES6 (ECMAScript 6) представил два новых способа объявления переменных: **const** и **let**, и, как правило, они рекомендуются во избежание неожиданных осложнений при подъеме.
**Ключевое слово var**
var имеет область действия функции;
объявления var поднимаются, но не инициализируются.

**const и let имеют область видимости блока.**
На самом деле объявления var, let, const, function и class поднимаются; но, мы должны помнить, что концепция поднятия не является буквальным процессом (т. е. сами объявления не перемещаются в начало файла - это просто процесс компилятора JavaScript, который сначала читает их, чтобы освободить для них место в памяти).

Разница между объявлениями var / function и объявлениями let / const / class заключается в инициализации. Первые инициализируются с неопределенным значением undefined. Однако, вторые, лексически объявленные переменные, остаются не инициализированными. Это означает, что ReferenceError выбрасывается при попытке доступа к ним. Они будут инициализированы только после того, как операторы let / const / class будут определены. Всё что до, называется временной мертвой зоной.

**Временная мертвая зона** - это не синтаксическое местоположение, а время между созданием переменной (области) и инициализацией. Ссылка на переменную в коде над объявлением не является ошибкой, если этот код не выполняется (например, тело функции или просто мертвый код), но ошибка будет выдана, если мы запросим доступ к переменной до её инициализации.

Разница между объявлениями var, let и const заключается в их инициализации.
Экземпляры var и let могут быть инициализированы без значения, в то время как const выдаст ошибку ReferenceError, если ты попытаешься объявить её без одновременного присвоения ей значения. Так что const myName = 'Alex' будет работать, но const myName; myName = 'Alex'; не будет. С помощью var и let ты можешь попробовать использовать значение var до того, как оно будет присвоено, и оно вернет undefined. Однако, если ты сделаешь то же самое с let - получишь ReferenceError.

**RECURSE**
Вернёмся к функциям и изучим их более подробно.
Нашей первой темой будет рекурсия.
Если вы не новичок в программировании, то, возможно, уже знакомы с рекурсией и можете пропустить эту главу.
Рекурсия – это приём программирования, полезный в ситуациях, когда задача может быть естественно разделена на несколько аналогичных, но более простых задач. Или когда задача может быть упрощена до несложных действий плюс простой вариант той же задачи. Или, как мы скоро увидим, для работы с определёнными структурами данных.


**CLOSURE**
**Замыкание**
JavaScript – язык с сильным функционально-ориентированным уклоном. Он даёт нам много свободы. Функция может быть динамически создана, скопирована в другую переменную или передана как аргумент другой функции и позже вызвана из совершенно другого места.
Мы знаем, что функция может получить доступ к переменным из внешнего окружения, эта возможность используется очень часто.
Но что произойдёт, когда внешние переменные изменятся? Функция получит последнее значение или то, которое существовало на момент создания функции?
И что произойдёт, когда функция переместится в другое место в коде и будет вызвана оттуда – получит ли она доступ к внешним переменным своего нового местоположения?
Разные языки ведут себя по-разному в таких случаях, и в этой главе мы рассмотрим поведение JavaScript.